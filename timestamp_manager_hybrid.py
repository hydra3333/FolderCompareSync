# ---------- Start of Common FileTimestampManager Code ----------
"""
A class to reliably manage file date-created and date-modified timestamps on Windows systems.

Purpose:
--------
    Handles both retrieval and setting of creation and modification times
    with proper timezone awareness for accurate file metadata preservation.
    Supports dry run mode to prevent actual filesystem modifications.

Features:
---------
    - Proper Windows FILETIME structure usage for maximum compatibility
    - Automatic timezone detection and conversion
    - Support for both files and directories
    - Dry run mode for testing
    - Fallback mechanism if primary method fails
    - Comprehensive error reporting

Usage:
------
    >>> timestamp_manager = FileTimestampManager()
    >>> 
    >>> # Get timestamps from a file
    >>> creation_time, mod_time = timestamp_manager.get_file_timestamps("source.txt")
    >>> 
    >>> # Set timestamps on another file
    >>> timestamp_manager.set_file_timestamps("target.txt", creation_time, mod_time)
    >>> 
    >>> # Copy timestamps directly
    >>> timestamp_manager.copy_timestamps("source.txt", "target.txt")
    >>> 
    >>> # Dry run mode (no actual changes)
    >>> dry_run_manager = FileTimestampManager(dry_run=True)

NOTES:
------
    Hybrid approach Generated by Claude AI.
    Robust FileTimestampManager class for Windows with proper type safety and fallback mechanisms.
    This hybrid approach combines the correctness of proper FILETIME structures with
    practical fallback options for maximum compatibility.
    Key improvements:
    - Proper FILETIME structure definition for type safety
    - Correct Windows API function signatures
    - Fallback mechanism if proper method fails
    - Enhanced error handling and debugging
    - Clear documentation of Windows timestamp quirks
"""

import os
import sys
import ctypes
from ctypes import wintypes
from datetime import datetime, timezone, timedelta
import time
import re
import argparse
import tempfile
import shutil
from pathlib import Path
from typing import Tuple, Optional, Union

# ==========================================================================================================
# WINDOWS FILETIME STRUCTURE AND API SETUP
# ==========================================================================================================
# Windows FILETIME is a 64-bit value representing 100-nanosecond intervals since January 1, 1601 UTC.
# It's stored as two 32-bit DWORDs: dwLowDateTime (low 32 bits) and dwHighDateTime (high 32 bits).
# 
# While passing a c_ulonglong pointer often works (on little-endian systems), using the proper
# FILETIME structure is more correct and ensures compatibility across different scenarios.
# ==========================================================================================================

class FILETIME(ctypes.Structure):
    """
    Windows FILETIME structure.
    Represents time as 100-nanosecond intervals since 1601-01-01 00:00:00 UTC.
    """
    _fields_ = [
        ("dwLowDateTime", wintypes.DWORD),   # Low 32 bits of the 64-bit time value
        ("dwHighDateTime", wintypes.DWORD),  # High 32 bits of the 64-bit time value
    ]

def _u64_to_FILETIME(u64: int) -> FILETIME:
    """
    Convert a 64-bit integer to a FILETIME structure.
    Args:
        u64: 64-bit integer representing 100-nanosecond intervals since 1601
    Returns:
        FILETIME structure with properly split low/high DWORDs
    """
    return FILETIME(
        dwLowDateTime=(u64 & 0xFFFFFFFF),        # Mask to get lower 32 bits
        dwHighDateTime=((u64 >> 32) & 0xFFFFFFFF) # Shift and mask to get upper 32 bits
    )

def _FILETIME_to_u64(ft: FILETIME) -> int:
    """
    Convert a FILETIME structure to a 64-bit integer.
    Args:
        ft: FILETIME structure
    Returns:
        64-bit integer representing 100-nanosecond intervals since 1601
    """
    return (ft.dwHighDateTime << 32) | ft.dwLowDateTime


# ==========================================================================================================
# WINDOWS API FUNCTION BINDINGS WITH PROPER SIGNATURES
# ==========================================================================================================
# Setting argtypes and restype ensures:
# 1. Proper type conversion (especially important for HANDLEs on 64-bit Python)
# 2. Correct error handling (return values won't be truncated)
# 3. Better debugging (ctypes will raise errors for incorrect argument types)
# ==========================================================================================================

kernel32 = ctypes.windll.kernel32

# CreateFileW - Opens a file/directory handle
kernel32.CreateFileW.argtypes = [
    wintypes.LPCWSTR,    # lpFileName (wide string path)
    wintypes.DWORD,      # dwDesiredAccess
    wintypes.DWORD,      # dwShareMode
    wintypes.LPVOID,     # lpSecurityAttributes (usually NULL)
    wintypes.DWORD,      # dwCreationDisposition
    wintypes.DWORD,      # dwFlagsAndAttributes
    wintypes.HANDLE      # hTemplateFile (usually NULL)
]
kernel32.CreateFileW.restype = wintypes.HANDLE

# SetFileTime - Sets file timestamps
kernel32.SetFileTime.argtypes = [
    wintypes.HANDLE,                 # hFile
    ctypes.POINTER(FILETIME),        # lpCreationTime (can be NULL)
    ctypes.POINTER(FILETIME),        # lpLastAccessTime (can be NULL)
    ctypes.POINTER(FILETIME)         # lpLastWriteTime (can be NULL)
]
kernel32.SetFileTime.restype = wintypes.BOOL

# CloseHandle - Closes an open handle
kernel32.CloseHandle.argtypes = [wintypes.HANDLE]
kernel32.CloseHandle.restype = wintypes.BOOL

# GetLastError - Gets the last Windows error code
kernel32.GetLastError.argtypes = []
kernel32.GetLastError.restype = wintypes.DWORD

# Windows constants
INVALID_HANDLE_VALUE = wintypes.HANDLE(-1).value
GENERIC_WRITE = 0x40000000
FILE_WRITE_ATTRIBUTES = 0x100  # More specific than GENERIC_WRITE for just changing attributes
FILE_SHARE_READ = 0x00000001
FILE_SHARE_WRITE = 0x00000002
OPEN_EXISTING = 3
FILE_ATTRIBUTE_NORMAL = 0x80
FILE_FLAG_BACKUP_SEMANTICS = 0x02000000  # Required for opening directories

# ==========================================================================================================
# MAIN TIMESTAMP MANAGER CLASS
# ==========================================================================================================

class FileTimestampManager:
    """
    A robust class to manage file timestamps on Windows systems.
    """
    
    def __init__(self, dry_run=False, debug=False):
        """
        Initialize the timestamp manager.
        
        Args:
            dry_run: If True, don't actually modify files (for testing)
            debug: If True, print detailed debug information
        """
        self._local_tz = self._get_local_timezone()
        self._windows_epoch = datetime(1601, 1, 1, tzinfo=timezone.utc)
        self._dry_run = dry_run
        self._debug = debug
        
        if self._debug:
            print(f"[DEBUG] Initialized with timezone: {self._local_tz}")
            print(f"[DEBUG] Dry run mode: {self._dry_run}")
    
    def _get_local_timezone(self):
        """
        Get the system's local timezone with multiple fallback methods.
        
        Returns:
            timezone object representing the local timezone
        """
        # Method 1: Try zoneinfo (Python 3.9+) with Windows timezone mapping
        try:
            import zoneinfo
            if hasattr(time, 'tzname') and time.tzname[0]:
                # Comprehensive Windows to IANA timezone mappings
                windows_to_iana = {
                    # Australian timezones
                    # --- start of change to fix Australian timezone mappings ---
                    'Cen. Australia Standard Time': 'Australia/Adelaide',
                    'Cen. Australia Daylight Time': 'Australia/Adelaide',
                    'Central Standard Time (Australia)': 'Australia/Adelaide',
                    'Central Daylight Time (Australia)': 'Australia/Adelaide',  # Added missing comma
                    'AUS Central Standard Time': 'Australia/Darwin',  # No DST in NT
                    'E. Australia Standard Time': 'Australia/Brisbane',  # No DST in QLD
                    'AUS Eastern Standard Time': 'Australia/Sydney',
                    'AUS Eastern Daylight Time': 'Australia/Sydney',  # Sydney has DST
                    'W. Australia Standard Time': 'Australia/Perth',  # No DST in WA
                    'Tasmania Standard Time': 'Australia/Hobart',
                    'Tasmania Daylight Time': 'Australia/Hobart',  # Tasmania has DST
                    # --- end of change to fix Australian timezone mappings ---
                    # US timezones
                    # --- start of change to add US Daylight Time variants ---
                    'Eastern Standard Time': 'America/New_York',
                    'Eastern Daylight Time': 'America/New_York',
                    'Central Standard Time': 'America/Chicago',
                    'Central Daylight Time': 'America/Chicago',
                    'Mountain Standard Time': 'America/Denver',
                    'Mountain Daylight Time': 'America/Denver',
                    'Pacific Standard Time': 'America/Los_Angeles',
                    'Pacific Daylight Time': 'America/Los_Angeles',
                    'Alaskan Standard Time': 'America/Anchorage',
                    'Alaskan Daylight Time': 'America/Anchorage',
                    'Hawaiian Standard Time': 'Pacific/Honolulu',  # Hawaii has no DST
                    # --- end of change to add US Daylight Time variants ---
                    # European timezones
                    # --- start of change to add European Summer Time variants ---
                    'GMT Standard Time': 'Europe/London',
                    'GMT Daylight Time': 'Europe/London',
                    'British Summer Time': 'Europe/London',  # BST
                    'W. Europe Standard Time': 'Europe/Berlin',
                    'W. Europe Daylight Time': 'Europe/Berlin',
                    'Central Europe Standard Time': 'Europe/Paris',
                    'Central Europe Daylight Time': 'Europe/Paris',
                    'Central European Summer Time': 'Europe/Paris',  # CEST
                    'E. Europe Standard Time': 'Europe/Athens',
                    'E. Europe Daylight Time': 'Europe/Athens',
                    # --- end of change to add European Summer Time variants ---
                    # Asian timezones (most don't observe DST)
                    'China Standard Time': 'Asia/Shanghai',
                    'Tokyo Standard Time': 'Asia/Tokyo',
                    'India Standard Time': 'Asia/Kolkata',
                    'Singapore Standard Time': 'Asia/Singapore',
                }

                # Try to map Windows timezone name to IANA
                win_tz_name = time.tzname[0]
                if win_tz_name in windows_to_iana:
                    return zoneinfo.ZoneInfo(windows_to_iana[win_tz_name])
                # Try the name directly (might work on some systems)
                try:
                    return zoneinfo.ZoneInfo(win_tz_name)
                except:
                    pass
        except (ImportError, AttributeError, Exception):
            pass
        
        # Method 2: Use time module offset to create timezone
        try:
            # Determine current offset from UTC
            #changed from: if time.daylight:
            #changed from:     offset_seconds = -time.altzone  # DST is in effect
            #changed from: else:
            #changed from:     offset_seconds = -time.timezone  # Standard time
            # Get the actual current offset by comparing local and UTC time
            import time
            local_time = time.localtime()
            utc_time = time.gmtime()
            # Calculate offset in seconds
            local_timestamp = time.mktime(local_time)
            utc_timestamp = time.mktime(utc_time) + (local_time.tm_isdst * 3600)
            offset_seconds = local_timestamp - utc_timestamp
            # Create timezone with the calculated offset
            return timezone(timedelta(seconds=offset_seconds))
        except:
            pass
        
        # Method 3: Final fallback to UTC
        print("[WARNING] Could not determine local timezone, using UTC")
        return timezone.utc
    
    def get_file_timestamps(self, file_path: Union[str, Path]) -> Tuple[datetime, datetime]:
        """
        Get creation and modification timestamps from a file or directory.
        
        Args:
            file_path: Path to the file or directory
            
        Returns:
            Tuple of (creation_time, modification_time) as timezone-aware datetime objects
            
        Raises:
            FileNotFoundError: If the file doesn't exist
            OSError: If there's an error accessing the file
        """
        file_path = Path(file_path)
        if not file_path.exists():
            raise FileNotFoundError(f"File not found: {file_path}")
        
        try:
            # Get timestamps as seconds since Unix epoch (1970-01-01)
            creation_timestamp = os.path.getctime(file_path)
            modification_timestamp = os.path.getmtime(file_path)
            
            # Convert to timezone-aware datetime objects in local timezone
            creation_time = datetime.fromtimestamp(creation_timestamp, tz=self._local_tz)
            modification_time = datetime.fromtimestamp(modification_timestamp, tz=self._local_tz)
            
            if self._debug:
                print(f"[DEBUG] Retrieved timestamps for {file_path}:")
                print(f"  Creation: {creation_time}")
                print(f"  Modified: {modification_time}")
            
            return creation_time, modification_time
        except OSError as e:
            raise OSError(f"Error accessing file timestamps for {file_path}: {e}")
    
    def set_file_timestamps(self, file_path: Union[str, Path], 
                          creation_time: Optional[datetime] = None,
                          modification_time: Optional[datetime] = None) -> bool:
        """
        Set creation and/or modification timestamps on a file or directory.
        
        Uses the proper FILETIME structure method first, with fallback to the
        simpler c_ulonglong method if needed.
        
        Args:
            file_path: Path to the file or directory
            creation_time: New creation time (optional)
            modification_time: New modification time (optional)
            
        Returns:
            True if successful, False otherwise
            
        Raises:
            FileNotFoundError: If the file doesn't exist
            ValueError: If neither timestamp is provided
        """
        if self._dry_run:
            print(f"[DRY RUN] Would set timestamps for {file_path}")
            return True
            
        if creation_time is None and modification_time is None:
            raise ValueError("At least one timestamp must be provided")
        
        file_path = Path(file_path)
        if not file_path.exists():
            raise FileNotFoundError(f"File not found: {file_path}")
        
        try:
            # Convert datetime objects to Windows FILETIME format (as 64-bit integers)
            creation_filetime = None
            modification_filetime = None
            
            if creation_time is not None:
                creation_filetime = self._datetime_to_filetime(creation_time)
                if self._debug:
                    #print(f"[DEBUG] Creation FILETIME: {creation_filetime}")
                    dt_display = self._filetime_to_datetime(creation_filetime)
                    print(f"[DEBUG] Creation FILETIME: {creation_filetime}")
                    print(f"        = {dt_display.strftime('%Y-%m-%d %H:%M:%S %Z')}")
            
            if modification_time is not None:
                modification_filetime = self._datetime_to_filetime(modification_time)
                if self._debug:
                    #print(f"[DEBUG] Modification FILETIME: {modification_filetime}")
                    dt_display = self._filetime_to_datetime(modification_filetime)
                    print(f"[DEBUG] Modification FILETIME: {modification_filetime}")
                    print(f"        = {dt_display.strftime('%Y-%m-%d %H:%M:%S %Z')}")
            
            # Try the proper FILETIME structure method first
            success = self._set_file_times_windows_proper(
                str(file_path), creation_filetime, modification_filetime
            )
            
            # If that fails, try the fallback method
            if not success and not self._debug:
                if self._debug:
                    print("[DEBUG] Primary method failed, trying fallback...")
                success = self._set_file_times_windows_fallback(
                    str(file_path), creation_filetime, modification_filetime
                )
            
            if success:
                if self._debug:
                    print(f"[DEBUG] Successfully set timestamps for {file_path}")
            else:
                print(f"[ERROR] Failed to set timestamps for {file_path}")
            
            return success
            
        except Exception as e:
            print(f"[ERROR] Error setting timestamps for {file_path}: {e}")
            return False
    
    def _datetime_to_filetime(self, dt: datetime) -> int:
        """
        Convert a datetime object to Windows FILETIME format.
        
        FILETIME represents the number of 100-nanosecond intervals since
        January 1, 1601 00:00:00 UTC (Windows epoch).
        
        Args:
            dt: Datetime object (timezone-aware or naive)
            
        Returns:
            Windows FILETIME as integer (100-nanosecond intervals since 1601-01-01)
        """
        # Ensure datetime is timezone-aware
        if dt.tzinfo is None:
            # Assume naive datetime is in local timezone
            dt = dt.replace(tzinfo=self._local_tz)
            if self._debug:
                print(f"[DEBUG] Converting naive datetime to local timezone: {dt}")
        
        # Convert to UTC for consistent FILETIME calculation
        dt_utc = dt.astimezone(timezone.utc)
        
        # Calculate time difference from Windows epoch (1601-01-01)
        time_diff = dt_utc - self._windows_epoch
        
        # Convert to 100-nanosecond intervals
        # total_seconds() gives us seconds as a float
        # Multiply by 10,000,000 to get 100-nanosecond intervals
        filetime = int(time_diff.total_seconds() * 10_000_000)
        
        return filetime

    def _filetime_to_datetime(self, filetime: int) -> datetime:
        """Convert FILETIME integer back to datetime for display."""
        seconds_since_1601 = filetime / 10_000_000
        dt_utc = self._windows_epoch + timedelta(seconds=seconds_since_1601)
        return dt_utc.astimezone(self._local_tz)
    
    def _set_file_times_windows_proper(self, file_path: str, 
                                      creation_time: Optional[int] = None,
                                      modification_time: Optional[int] = None) -> bool:
        """
        Primary method: Use Windows API with proper FILETIME structures.
        
        This is the most correct way to set file times on Windows.
        
        Args:
            file_path: Path to the file or directory
            creation_time: Creation time in FILETIME format (optional)
            modification_time: Modification time in FILETIME format (optional)
            
        Returns:
            True if successful, False otherwise
        """
        handle = None
        try:
            # Determine if path is a directory
            is_directory = os.path.isdir(file_path)
            
            # Set appropriate flags
            flags = FILE_ATTRIBUTE_NORMAL
            if is_directory:
                # Must use FILE_FLAG_BACKUP_SEMANTICS to open directories
                flags = FILE_FLAG_BACKUP_SEMANTICS
            
            # Open file/directory handle
            # Using FILE_WRITE_ATTRIBUTES is more specific than GENERIC_WRITE
            handle = kernel32.CreateFileW(
                file_path,
                FILE_WRITE_ATTRIBUTES,  # Only need attribute write access
                FILE_SHARE_READ | FILE_SHARE_WRITE,  # Allow other processes to read/write
                None,  # Default security
                OPEN_EXISTING,  # File must exist
                flags,
                None  # No template file
            )
            
            if handle == INVALID_HANDLE_VALUE:
                if self._debug:
                    error_code = kernel32.GetLastError()
                    print(f"[DEBUG] CreateFileW failed with error code: {error_code}")
                return False
            
            # Prepare FILETIME structures
            creation_ft_ptr = None
            modification_ft_ptr = None
            
            if creation_time is not None:
                creation_ft = _u64_to_FILETIME(creation_time)
                creation_ft_ptr = ctypes.pointer(creation_ft)
            
            if modification_time is not None:
                modification_ft = _u64_to_FILETIME(modification_time)
                modification_ft_ptr = ctypes.pointer(modification_ft)
            
            # Set file times
            # NULL for lpLastAccessTime means don't change access time
            result = kernel32.SetFileTime(
                handle,
                creation_ft_ptr,      # Creation time
                None,                 # Last access time (unchanged)
                modification_ft_ptr   # Modification time
            )
            
            if not result and self._debug:
                error_code = kernel32.GetLastError()
                print(f"[DEBUG] SetFileTime failed with error code: {error_code}")
            
            return bool(result)
            
        except Exception as e:
            if self._debug:
                print(f"[DEBUG] Exception in proper method: {e}")
            return False
        finally:
            # Always close the handle if it was opened
            if handle and handle != INVALID_HANDLE_VALUE:
                kernel32.CloseHandle(handle)
    
    def _set_file_times_windows_fallback(self, file_path: str, 
                                        creation_time: Optional[int] = None,
                                        modification_time: Optional[int] = None) -> bool:
        """
        Fallback method: Use Windows API with c_ulonglong (simpler but less correct).
        
        This method works on most Windows systems due to little-endian memory layout,
        but is technically not the correct way to pass FILETIME structures.
        
        Args:
            file_path: Path to the file or directory
            creation_time: Creation time in FILETIME format (optional)
            modification_time: Modification time in FILETIME format (optional)
            
        Returns:
            True if successful, False otherwise
        """
        handle = None
        try:
            # Determine if path is a directory
            is_directory = os.path.isdir(file_path)
            
            # Set appropriate flags
            flags = FILE_ATTRIBUTE_NORMAL
            if is_directory:
                flags = FILE_FLAG_BACKUP_SEMANTICS
            
            # Open file/directory handle (using simpler approach without type hints)
            handle = ctypes.windll.kernel32.CreateFileW(
                file_path,
                wintypes.DWORD(GENERIC_WRITE),
                wintypes.DWORD(FILE_SHARE_READ | FILE_SHARE_WRITE),
                None,
                wintypes.DWORD(OPEN_EXISTING),
                wintypes.DWORD(flags),
                None
            )
            
            if handle == -1:  # Simple comparison for INVALID_HANDLE_VALUE
                return False
            
            # Prepare FILETIME as c_ulonglong (fallback method)
            creation_ft = None
            modification_ft = None
            
            if creation_time is not None:
                creation_ft = ctypes.byref(ctypes.c_ulonglong(creation_time))
            
            if modification_time is not None:
                modification_ft = ctypes.byref(ctypes.c_ulonglong(modification_time))
            
            # Set file times
            result = ctypes.windll.kernel32.SetFileTime(
                handle,
                creation_ft,
                None,
                modification_ft
            )
            
            return bool(result)
            
        except Exception as e:
            if self._debug:
                print(f"[DEBUG] Exception in fallback method: {e}")
            return False
        finally:
            # Always close the handle if it was opened
            if handle and handle != -1:
                ctypes.windll.kernel32.CloseHandle(handle)
    
    def copy_timestamps(self, source_file: Union[str, Path], 
                       target_file: Union[str, Path]) -> bool:
        """
        Copy timestamps from source file to target file.
        
        This is a convenience method that combines get_file_timestamps
        and set_file_timestamps.
        
        Args:
            source_file: Source file path
            target_file: Target file path
            
        Returns:
            True if successful, False otherwise
        """
        if self._dry_run:
            print(f"[DRY RUN] Would copy timestamps from {source_file} to {target_file}")
            return True
            
        try:
            # Get timestamps from source
            creation_time, modification_time = self.get_file_timestamps(source_file)
            
            # Set timestamps on target
            success = self.set_file_timestamps(target_file, creation_time, modification_time)
            
            if success and self._debug:
                print(f"[DEBUG] Successfully copied timestamps from {source_file} to {target_file}")
            
            return success
            
        except Exception as e:
            print(f"[ERROR] Error copying timestamps: {e}")
            return False
    
    def format_timestamp(self, dt: datetime, include_timezone: bool = True) -> str:
        """
        Format a datetime object for display.
        
        Args:
            dt: Datetime object
            include_timezone: Whether to include timezone info in output
            
        Returns:
            Formatted datetime string
        """
        if include_timezone:
            return dt.strftime("%Y-%m-%d %H:%M:%S %Z")
        else:
            return dt.strftime("%Y-%m-%d %H:%M:%S")
    
    def verify_timestamps(self, file_path: Union[str, Path], 
                         expected_creation: Optional[datetime] = None,
                         expected_modification: Optional[datetime] = None,
                         tolerance_seconds: float = 1.0) -> bool:
        """
        Verify that a file has the expected timestamps (within tolerance).
        
        Useful for testing and validation.
        
        Args:
            file_path: Path to verify
            expected_creation: Expected creation time (optional)
            expected_modification: Expected modification time (optional)
            tolerance_seconds: Acceptable difference in seconds
            
        Returns:
            True if timestamps match within tolerance, False otherwise
        """
        try:
            actual_creation, actual_modification = self.get_file_timestamps(file_path)
            
            if expected_creation is not None:
                diff = abs((actual_creation - expected_creation).total_seconds())
                if diff > tolerance_seconds:
                    if self._debug:
                        print(f"[DEBUG] Creation time mismatch: {diff} seconds")
                    return False
            
            if expected_modification is not None:
                diff = abs((actual_modification - expected_modification).total_seconds())
                if diff > tolerance_seconds:
                    if self._debug:
                        print(f"[DEBUG] Modification time mismatch: {diff} seconds")
                    return False
            
            return True
            
        except Exception as e:
            if self._debug:
                print(f"[DEBUG] Error verifying timestamps: {e}")
            return False

# ---------- End of Common FileTimestampManager Code ----------

# ==========================================================================================================
# EXAMPLE USAGE AND TESTING
# ==========================================================================================================
if __name__ == "__main__":
    """
    Example usage and basic testing of the FileTimestampManager class.
    """
    from datetime import timedelta

    # Create manager with debug output enabled
    manager = FileTimestampManager(debug=True)
    
    # Example 1: Get timestamps from a file
    test_file = "test_file.txt"
    if os.path.exists(test_file):
        print(f"Removing existing file: {test_file} at {datetime.now()}")
        os.remove(test_file)
    print(f"Creating  new file: {test_file} at {datetime.now()}")
    with open(test_file, 'w') as f:
        f.write("This is a test file for timestamp testing\n")
        f.write(f"Created at: {datetime.now()}\n")
    time.sleep(5) 
    print(f"Path(test_file).touch() newly created file: {test_file} at {datetime.now()}")
    Path(test_file).touch()

    if os.path.exists(test_file):
        print("\n=== Getting timestamps ===")
        creation, modification = manager.get_file_timestamps(test_file)
        print(f"Creation time: {manager.format_timestamp(creation)}")
        print(f"Modification time: {manager.format_timestamp(modification)}")
        
        # Example 2: Set new timestamps
        print("\n=== Setting new timestamps ===")
        new_creation = creation - timedelta(days=30)
        new_modification = modification - timedelta(days=7)
        
        success = manager.set_file_timestamps(test_file, new_creation, new_modification)
        print(f"Set timestamps: {'Success' if success else 'Failed'}")
        
        # Example 3: Verify the change
        print("\n=== Verifying timestamps ===")
        verified = manager.verify_timestamps(test_file, new_creation, new_modification)
        print(f"Verification: {'Passed' if verified else 'Failed'}")
    
    # Example 4: Dry run mode
    print("\n=== Dry run mode ===")
    dry_manager = FileTimestampManager(dry_run=True, debug=True)
    if os.path.exists("source.txt") and os.path.exists("target.txt"):
        dry_manager.copy_timestamps("source.txt", "target.txt")
