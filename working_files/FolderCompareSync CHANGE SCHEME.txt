PLEASE ALWAYS USE THESE MANDATORY FEATURES AND CODE CHANGE RULES

# MANDATORY FEATURES AND "FolderCompareSync CHANGE SCHEME" RULES

## MANDATORY FEATURES WHICH MUST BE MAINTAINED ACROSS ALL CHANGES AND VERSIONS:

We must ALWAYS explicitly ensure when creating/updating code and when running the program - and verify after all code changes, 
perhaps through a review and through implementing a verification def which is called after (re)building any data structures eg say after a compare or a sort, that:

### (1) Folder Tree Structure Preservation
- The Folder tree structures NEVER changes after a compare 
- Folders in the folder trees in both the LEFT and the RIGHT must stay and be displayed in their hierarchy, including missing ones.

### (2) Row Correspondence Maintenance  
- Row correspondence is maintained for files and folders across the folder trees in the LEFT and the RIGHT
- When folders and files in "Folder A" (including "missing" ones) are shown on the LEFT then the corresponding files in "Folder A" (including "missing" ones) are shown on the RIGHT follow the same order 
- Both matching entries in LEFT and RIGHT appear as a pair and are guaranteed to always appear in the same row.

### (3) Future Sorting Rules (if implemented)
If in the future we choose to implement file sorting by varying optional criteria then it is mandatory that:
- **(a)** only files within each folder level will get sorted 
- **(b)** files sort among their "siblings" in the same parent folder
- **(c)** row correspondence is maintained for files and folders and within each folder across both halves LEFT and RIGHT
- **(d)** scrolling is still synchronized across the 2 halves so that files/folders are always shown in the same row when scrolling up and down
- **(e)** file/folder pairs across the 2 display trees always display together as a stable pair on one row even when sorted
- **(f)** Example behavior: If clicking "Size" in LEFT tree, Documents/ folder files reorder by size, Images/ folder files reorder by size, RIGHT tree files follow the same reordering to maintain row alignment, but folders themselves (Documents/, Images/) stay in original positions

### (4) Core Tool Purpose Preservation
This approach:
- Maintains directory navigation structure
- Keeps the tool's core comparison purpose intact 
- Preserves left and right comparison alignment within each folder across both halves 
- Makes it easy for the end user to compare folder trees
- Allows for useful sorting of files within each directory ensuring directory/file comparison structure appears consistent, with row correspondence, to the end user

---

## "FolderCompareSync CHANGE SCHEME" CODE CHANGE RULES

### Overview
This is our agreed change scheme named "FolderCompareSync CHANGE SCHEME" for making code modifications in a clear, traceable way.

### Rules:

#### **Rule 1: Version Number Updates**
- Always update the version and revision number "vxxxx.yyyy" in the comments near the top of the Program
- Example: Initially Version v000.0004 is bumped up to v000.0005, where the 0004 is changed to the next new number in sequence for this code change

#### **Rule 2: Line-by-Line Change Marking** 
- Clearly mark every added or changed line of code with one of these texts **AT THE END OF EVERY ADDED OR CHANGED LINE**:
  - `# vxxxx.yyyy added [brief relevant description, or common change identifying text]`
  - `# vxxxx.yyyy changed [brief relevant description, or common change identifying text]`
- Use whatever new number matches from applying rule 1

#### **Rule 3: Code Quality and Comments**
- All code must be well commented and meaningful 
- Keep/amend existing comments of clarification as appropriate 
- Remove obsolete comments

#### **Rule 4: Variable/Function Name Preservation**
- Do not change existing variable names or def names or class names or import names etc unless good reason exists to do so
- Good reasons: purpose or meaning has changed, or for clarification
- A change of name for the reason of a preference in variable naming is not necessarily desirable unless it increases clarity

#### **Rule 5: Artifact Creation Rules - CRITICAL**
- **No full code display** - do not show me the updated full program unless specifically requested
- **Instead of showing me updated full program code, only show me the new/changed/deleted def's etc into new downloadable artifacts**
- **Each def/method/class gets its own separate artifact**
- Where code at the "top level" is changed then the block of changed code should be displayed with 10 lines of existing unchanged code either side to assist me in locating that change in the program
- Rule 2 of this "FolderCompareSync CHANGE SCHEME" is particularly important for artifact creation

#### **Rule 6: Structure Documentation**
- After showing me updated code according to these rules or other specific request, then also show me in a new downloadable artifact a full structure tree of def's etc
- Format like this example denoting where new/changed/deleted def's are in the program in sequence and in relative depth to each other via multi level indentation:

```
Def and Class Relative Positions:
=Root level code block outside of def or class
_u64_to_FILETIME()
_FILETIME_to_u64()
class FileTimestampManager 
	├── __init__()
	├── def_01()
	├── def_02()
    │   ├── imaginary_01()
    │   ├── imaginary_02() # ****UPDATED****
    │   ├── class MissingFolder
    │   │   ├──  __init__()
    │   │   └── nested_imaginary_01() # ****UPDATED****
    │   └── imaginary_03()
    ├── Crikey_01()
    │   ├── Crikey_02()
    │   └── Crikey_03() # ****UPDATED****
	├── def_03()
	└── def_04() # ****NEW****
class class_05 # ****NEW****
	├── __init__() # ****NEW****
	└── def_06() # ****NEW****
main()
=Root level code block outside of def or class
```

### Benefits:
- Preserves visibility of original code
- Easy to review changes
- Clearly marks all modifications  
- Simple to locate changes to revert when required
- Helps identify proper code indentation during code maintenance
- Shows exact scope of each change
- Minimal output when showing proposed changes
- **Each function/method in its own artifact for clarity and maintainability**