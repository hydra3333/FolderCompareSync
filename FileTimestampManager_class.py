# from __future__ imports MUST occur at the beginning of the file, annotations become strings resolved lazily
from __future__ import annotations 

# import out global imports
from FolderCompareSync_Global_Imports import *

# import out global constants first
import FolderCompareSync_Global_Constants as C

# import our flushed_logging before other modules
#from flushed_logging import *   # includes LoggerManager
from flushed_logging import log_and_flush, get_log_level, LoggerManager

# Import the things this class references
# nil

class FileTimestampManager_class:
    """
    A robust class to manage file timestamps on Windows systems.
    """
    
    # class FILETIME must must must be defined before the WINDOWS API FUNCTION BINDINGS below
    class FILETIME(ctypes.Structure):
        # ==========================================================================================================
        # WINDOWS FILETIME STRUCTURE AND API SETUP
        # ==========================================================================================================
        # Windows FILETIME is a 64-bit value representing 100-nanosecond intervals since January 1, 1601 UTC.
        # It's stored as two 32-bit DWORDs: dwLowDateTime (low 32 bits) and dwHighDateTime (high 32 bits).
        # 
        # While passing a c_ulonglong pointer often works (on little-endian systems), using the proper
        # FILETIME structure is more correct and ensures compatibility across different scenarios.
        # ==
        """
        Windows FILETIME structure.
        Represents time as 100-nanosecond intervals since 1601-01-01 00:00:00 UTC.
    
        A class to reliably manage file date-created and date-modified timestamps on Windows systems.
    
        Purpose:
        --------
            Handles both retrieval and setting of creation and modification times
            with proper timezone awareness for accurate file metadata preservation.
            Supports dry run mode to prevent actual filesystem modifications.
        
        Features:
        ---------
            - Proper Windows FILETIME structure usage for maximum compatibility
            - Automatic timezone detection and conversion
            - Support for both files and directories
            - Dry run mode for testing
            - Fallback mechanism if primary method fails
            - Comprehensive error reporting
        
        Usage:
        ------
            >>> timestamp_manager = FileTimestampManager_class()
            >>> 
            >>> # Get timestamps from a file
            >>> creation_time, mod_time = timestamp_manager.get_file_timestamps("source.txt")
            >>> 
            >>> # Set timestamps on another file
            >>> timestamp_manager.set_file_timestamps("target.txt", creation_time, mod_time)
            >>> 
            >>> # Copy timestamps directly
            >>> timestamp_manager.copy_timestamps("source.txt", "target.txt")
            >>> 
            >>> # Dry run mode (no actual changes)
            >>> dry_run_manager = FileTimestampManager_class(dry_run=True)
        
        NOTES:
        ------
            Hybrid approach Generated by Claude AI.
            Robust FileTimestampManager_class class for Windows with proper type safety and fallback mechanisms.
            This hybrid approach combines the correctness of proper FILETIME structures with
            practical fallback options for maximum compatibility.
            Key improvements:
            - Proper FILETIME structure definition for type safety
            - Correct Windows API function signatures
            - Fallback mechanism if proper method fails
            - error handling and debugging
            - Clear documentation of Windows timestamp quirks
        """
        _fields_ = [
            ("dwLowDateTime", wintypes.DWORD),   # Low 32 bits of the 64-bit time value
            ("dwHighDateTime", wintypes.DWORD),  # High 32 bits of the 64-bit time value
        ]


    # ==========================================================================================================
    # WINDOWS API FUNCTION BINDINGS WITH PROPER SIGNATURES
    # ==========================================================================================================
    # Setting argtypes and restype ensures:
    # 1. Proper type conversion (especially important for HANDLEs on 64-bit Python)
    # 2. Correct error handling (return values won't be truncated)
    # 3. Better debugging (ctypes will raise errors for incorrect argument types)
    # ==========================================================================================================

    kernel32 = ctypes.windll.kernel32

    # CreateFileW - Opens a file/directory handle
    kernel32.CreateFileW.argtypes = [
        wintypes.LPCWSTR,    # lpFileName (wide string path)
        wintypes.DWORD,      # dwDesiredAccess
        wintypes.DWORD,      # dwShareMode
        wintypes.LPVOID,     # lpSecurityAttributes (usually NULL)
        wintypes.DWORD,      # dwCreationDisposition
        wintypes.DWORD,      # dwFlagsAndAttributes
        wintypes.HANDLE      # hTemplateFile (usually NULL)
    ]
    kernel32.CreateFileW.restype = wintypes.HANDLE

    # SetFileTime - Sets file timestamps
    kernel32.SetFileTime.argtypes = [
        wintypes.HANDLE,                 # hFile
        ctypes.POINTER(FILETIME),        # lpCreationTime (can be NULL)
        ctypes.POINTER(FILETIME),        # lpLastAccessTime (can be NULL)
        ctypes.POINTER(FILETIME)         # lpLastWriteTime (can be NULL)
    ]
    kernel32.SetFileTime.restype = wintypes.BOOL

    # CloseHandle - Closes an open handle
    kernel32.CloseHandle.argtypes = [wintypes.HANDLE]
    kernel32.CloseHandle.restype = wintypes.BOOL

    # GetLastError - Gets the last Windows error code
    kernel32.GetLastError.argtypes = []
    kernel32.GetLastError.restype = wintypes.DWORD

    # Windows constants
    INVALID_HANDLE_VALUE = wintypes.HANDLE(-1).value
    GENERIC_WRITE = 0x40000000
    FILE_WRITE_ATTRIBUTES = 0x100  # More specific than GENERIC_WRITE for just changing attributes
    FILE_SHARE_READ = 0x00000001
    FILE_SHARE_WRITE = 0x00000002
    OPEN_EXISTING = 3
    FILE_ATTRIBUTE_NORMAL = 0x80
    FILE_FLAG_BACKUP_SEMANTICS = 0x02000000  # Required for opening directories

    @staticmethod
    def _u64_to_FILETIME(u64: int) -> FileTimestampManager_class.FILETIME:
        """
        Convert a 64-bit integer to a FILETIME structure.
        Args:
            u64: 64-bit integer representing 100-nanosecond intervals since 1601
        Returns:
            FILETIME structure with properly split low/high DWORDs
        """
        return FileTimestampManager_class.FILETIME(
            dwLowDateTime=(u64 & 0xFFFFFFFF),        # Mask to get lower 32 bits
            dwHighDateTime=((u64 >> 32) & 0xFFFFFFFF) # Shift and mask to get upper 32 bits
        )

    @staticmethod
    def _FILETIME_to_u64(ft: FileTimestampManager_class.FILETIME) -> int:
        """
        Convert a FILETIME structure to a 64-bit integer.
        Args:
            ft: FILETIME structure
        Returns:
            64-bit integer representing 100-nanosecond intervals since 1601
        """
        return (ft.dwHighDateTime << 32) | ft.dwLowDateTime
    
    def __init__(self, dry_run=False):
        """
        Initialize the timestamp manager.
        
        Args:
            dry_run: If True, don't actually modify files (for testing)
            debug: If True, print detailed debug information
        """
        self._local_tz = self._get_local_timezone()
        self._windows_epoch = datetime(1601, 1, 1, tzinfo=timezone.utc)
        self._dry_run = dry_run
        log_and_flush(logging.DEBUG, f"FileTimestampManager_class initialized with timezone: {self.get_timezone_string()}")
        log_and_flush(logging.DEBUG, f"FileTimestampManager_class dry run mode: {self._dry_run}")

    def get_timezone_string(self) -> str:
        """
        Get a human-readable string representation of the detected timezone.
        
        Returns:
            String describing the timezone (e.g., "Australia/Adelaide" or "UTC+09:30")
        """
        if hasattr(self._local_tz, 'key'):
            # zoneinfo.ZoneInfo has a 'key' attribute with the IANA name
            return self._local_tz.key
        elif hasattr(self._local_tz, 'tzname'):
            # Some timezone objects have tzname method
            try:
                return self._local_tz.tzname(datetime.now())
            except:
                pass
        
        # For timezone objects created from offset, show the offset
        try:
            offset = self._local_tz.utcoffset(datetime.now())
            if offset:
                total_seconds = int(offset.total_seconds())
                hours, remainder = divmod(abs(total_seconds), 3600)
                minutes = remainder // 60
                sign = '+' if total_seconds >= 0 else '-'
                if minutes:
                    return f"UTC{sign}{hours:02d}:{minutes:02d}"
                else:
                    return f"UTC{sign}{hours:02d}:00"
        except:
            pass
        
        # Fallback
        return str(self._local_tz)

    def _get_local_timezone(self):
        """
        Get the system's local timezone with multiple fallback methods.
        
        Returns:
            timezone object representing the local timezone
        """
        # Method 0: Use dateutil.tz.tzwinlocal (Windows registry direct)
        log_and_flush(logging.DEBUG, "Attempting timezone detection using Method 0: dateutil.tz.tzwinlocal...")
        try:
            tz = tzwinlocal()
            if tz:
                # Get a human-readable description
                tz_name = tz.tzname(datetime.now())
                log_and_flush(logging.INFO, f"Timezone detected via Method 0: dateutil.tz.tzwinlocal: {tz_name}")
                return tz
        except Exception as e:
            log_and_flush(logging.DEBUG, f"tzwinlocal method failed: {e}")

        # Method 1: Try zoneinfo (Python 3.9+) with Windows timezone mapping
        log_and_flush(logging.DEBUG, "Attempting timezone detection using Method 1: zoneinfo method...")
        try:
            if hasattr(time, 'tzname') and time.tzname[0]:
                # Comprehensive Windows to IANA timezone mappings
                windows_to_iana = {
                    # Australian timezones
                    'Cen. Australia Standard Time': 'Australia/Adelaide',
                    'Cen. Australia Daylight Time': 'Australia/Adelaide',
                    'Central Standard Time (Australia)': 'Australia/Adelaide',
                    'Central Daylight Time (Australia)': 'Australia/Adelaide',
                    'AUS Central Standard Time': 'Australia/Darwin',  # No DST in NT
                    'E. Australia Standard Time': 'Australia/Brisbane',  # No DST in QLD
                    'AUS Eastern Standard Time': 'Australia/Sydney',
                    'AUS Eastern Daylight Time': 'Australia/Sydney',  # Sydney has DST
                    'W. Australia Standard Time': 'Australia/Perth',  # No DST in WA
                    'Tasmania Standard Time': 'Australia/Hobart',
                    'Tasmania Daylight Time': 'Australia/Hobart',  # Tasmania has DST
                    # US timezones
                    'Eastern Standard Time': 'America/New_York',
                    'Eastern Daylight Time': 'America/New_York',
                    'Central Standard Time': 'America/Chicago',
                    'Central Daylight Time': 'America/Chicago',
                    'Mountain Standard Time': 'America/Denver',
                    'Mountain Daylight Time': 'America/Denver',
                    'Pacific Standard Time': 'America/Los_Angeles',
                    'Pacific Daylight Time': 'America/Los_Angeles',
                    'Alaskan Standard Time': 'America/Anchorage',
                    'Alaskan Daylight Time': 'America/Anchorage',
                    'Hawaiian Standard Time': 'Pacific/Honolulu',  # Hawaii has no DST
                    # European timezones
                    'GMT Standard Time': 'Europe/London',
                    'GMT Daylight Time': 'Europe/London',
                    'British Summer Time': 'Europe/London',  # BST
                    'W. Europe Standard Time': 'Europe/Berlin',
                    'W. Europe Daylight Time': 'Europe/Berlin',
                    'Central Europe Standard Time': 'Europe/Paris',
                    'Central Europe Daylight Time': 'Europe/Paris',
                    'Central European Summer Time': 'Europe/Paris',  # CEST
                    'E. Europe Standard Time': 'Europe/Athens',
                    'E. Europe Daylight Time': 'Europe/Athens',
                    # Asian timezones (most don't observe DST)
                    'China Standard Time': 'Asia/Shanghai',
                    'Tokyo Standard Time': 'Asia/Tokyo',
                    'India Standard Time': 'Asia/Kolkata',
                    'Singapore Standard Time': 'Asia/Singapore',
                }
                # Try to map Windows timezone name to IANA
                win_tz_name = time.tzname[0]
                log_and_flush(logging.DEBUG, f"Windows timezone name detected: {win_tz_name}")
                
                if win_tz_name in windows_to_iana:
                    iana_name = windows_to_iana[win_tz_name]
                    tz = zoneinfo.ZoneInfo(iana_name)
                    log_and_flush(logging.INFO, f"Timezone detected via Method 1a: zoneinfo mapping: {iana_name} (from Windows: {win_tz_name})")
                    return tz
                    
                # Try the name directly (might work on some systems)
                try:
                    tz = zoneinfo.ZoneInfo(win_tz_name)
                    log_and_flush(logging.INFO, f"Timezone detected via Method 1b: zoneinfo direct: {win_tz_name}")
                    return tz
                except:
                    log_and_flush(logging.DEBUG, f"Could not use Windows timezone name directly: {win_tz_name}")
        except zoneinfo.ZoneInfoNotFoundError as e:
            log_and_flush(logging.WARNING, f"IANA lookup failed (no tzdata?): {e}")
        except ImportError as e:
            log_and_flush(logging.DEBUG, "zoneinfo module not available, {e},skipping Method 1")
        except (AttributeError, Exception) as e:
            log_and_flush(logging.DEBUG, f"Zoneinfo method failed: {e}")
        
        # Method 2: Use time module offset to create timezone
        log_and_flush(logging.DEBUG, "Attempting timezone detection using Method 2: time module offset method...")
        try:
            # We already have time imported at module level â€“ do not do an inner import here!
            # Get the actual current offset by comparing local and UTC time
            local_time = time.localtime()
            utc_time   = time.gmtime()
            # Calculate integer offset in seconds
            local_timestamp = int(time.mktime(local_time))
            utc_timestamp   = int(time.mktime(utc_time)) + (local_time.tm_isdst * 3600)
            offset_seconds  = local_timestamp - utc_timestamp
            # Create timezone object with the calculated offset
            tz = timezone(timedelta(seconds=offset_seconds))
            # Log the offset details with integer formatting
            abs_off = abs(offset_seconds)
            hours = abs_off // 3600
            minutes = (abs_off % 3600) // 60
            sign = '+' if offset_seconds >= 0 else '-'
            offset_str = (
                f"UTC{sign}{hours:02d}:{minutes:02d}" if minutes else f"UTC{sign}{hours:02d}:00"
            )
            log_and_flush(logging.INFO, f"Timezone detected via Method 2: time module offset: {offset_str}")
            return tz
        except Exception as e:
            log_and_flush(logging.DEBUG, f"Time module offset method failed: {e}")
        
        # Method 3: Final fallback to UTC
        log_and_flush(logging.WARNING, "Could not determine local timezone, falling back to Method 3: UTC")
        return timezone.utc
    
    def get_file_timestamps(self, file_path: Union[str, Path]) -> tuple[datetime, datetime]:
        """
        Get creation and modification timestamps from a file or directory.
        
        Args:
            file_path: Path to the file or directory
            
        Returns:
            tuple of (creation_time, modification_time) as timezone-aware datetime objects
            
        Raises:
            FileNotFoundError: If the file doesn't exist
            OSError: If there's an error accessing the file
        """
        file_path = Path(file_path)
        if not file_path.exists():
            raise FileNotFoundError(f"File not found: {file_path}")
        
        try:
            # Get timestamps as seconds since Unix epoch (1970-01-01)
            creation_timestamp = os.path.getctime(file_path)
            modification_timestamp = os.path.getmtime(file_path)
            
            # Convert to timezone-aware datetime objects in local timezone
            creation_time = datetime.fromtimestamp(creation_timestamp, tz=self._local_tz)
            modification_time = datetime.fromtimestamp(modification_timestamp, tz=self._local_tz)
            
            log_and_flush(logging.DEBUG, f"Retrieved timestamps for {file_path}:")
            log_and_flush(logging.DEBUG, f"  Creation: {creation_time}")
            log_and_flush(logging.DEBUG, f"  Modified: {modification_time}")
            
            return creation_time, modification_time
        except OSError as e:
            raise OSError(f"Error accessing file timestamps for {file_path}: {e}")
    
    def set_file_timestamps(self, file_path: Union[str, Path], 
                          creation_time: Optional[datetime] = None,
                          modification_time: Optional[datetime] = None) -> bool:
        """
        Set creation and/or modification timestamps on a file or directory.
        
        Uses the proper FILETIME structure method first, with fallback to the
        simpler c_ulonglong method if needed.
        
        Args:
            file_path: Path to the file or directory
            creation_time: New creation time (optional)
            modification_time: New modification time (optional)
            
        Returns:
            True if successful, False otherwise
            
        Raises:
            FileNotFoundError: If the file doesn't exist
            ValueError: If neither timestamp is provided
        """
        if self._dry_run:
            log_and_flush(logging.INFO, f"[DRY RUN] Would set timestamps for {file_path}")
            return True
            
        if creation_time is None and modification_time is None:
            raise ValueError("At least one timestamp must be provided")
        
        file_path = Path(file_path)
        if not file_path.exists():
            raise FileNotFoundError(f"File not found: {file_path}")
        
        try:
            # Convert datetime objects to Windows FILETIME format (as 64-bit integers)
            creation_filetime = None
            modification_filetime = None
            
            if creation_time is not None:
                creation_filetime = self._datetime_to_filetime(creation_time)
                dt_display = self._filetime_to_datetime(creation_filetime)
                log_and_flush(logging.DEBUG, f"Creation FILETIME: {creation_filetime}")
                log_and_flush(logging.DEBUG, f"        = {dt_display.strftime('%Y-%m-%d %H:%M:%S %Z')}")
            
            if modification_time is not None:
                modification_filetime = self._datetime_to_filetime(modification_time)
                dt_display = self._filetime_to_datetime(modification_filetime)
                log_and_flush(logging.DEBUG, f"Modification FILETIME: {modification_filetime}")
                log_and_flush(logging.DEBUG, f"        = {dt_display.strftime('%Y-%m-%d %H:%M:%S %Z')}")
            
            # Try the proper FILETIME structure method first
            success = self._set_file_times_windows_proper(
                str(file_path), creation_filetime, modification_filetime
            )
            
            # If that fails, try the fallback method
            if not success:
                log_and_flush(logging.DEBUG, "Primary method failed, trying fallback...")
                success = self._set_file_times_windows_fallback(
                    str(file_path), creation_filetime, modification_filetime
                )
            if success:
                log_and_flush(logging.DEBUG, f"Successfully set timestamps for {file_path}")
            else:
                log_and_flush(logging.ERROR, f"Failed to set timestamps for {file_path}")
            return success
        except Exception as e:
            log_and_flush(logging.ERROR, f"Error setting timestamps for {file_path}: {e}")
            return False
    
    def _datetime_to_filetime(self, dt: datetime) -> int:
        """
        Convert a datetime object to Windows FILETIME format.
        
        FILETIME represents the number of 100-nanosecond intervals since
        January 1, 1601 00:00:00 UTC (Windows epoch).
        
        Args:
            dt: Datetime object (timezone-aware or naive)
            
        Returns:
            Windows FILETIME as integer (100-nanosecond intervals since 1601-01-01)
        """
        # Ensure datetime is timezone-aware
        if dt.tzinfo is None:
            # Assume naive datetime is in local timezone
            dt = dt.replace(tzinfo=self._local_tz)
            log_and_flush(logging.DEBUG, f"Converting naive datetime to local timezone: {dt}")
        
        # Convert to UTC for consistent FILETIME calculation
        dt_utc = dt.astimezone(timezone.utc)
        
        # Calculate time difference from Windows epoch (1601-01-01)
        time_diff = dt_utc - self._windows_epoch
        
        # Convert to 100-nanosecond intervals
        # total_seconds() gives us seconds as a float
        # Multiply by 10,000,000 to get 100-nanosecond intervals
        filetime = int(time_diff.total_seconds() * 10_000_000)
        
        return filetime

    def _filetime_to_datetime(self, filetime: int) -> datetime:
        """Convert FILETIME integer back to datetime for display."""
        seconds_since_1601 = filetime / 10_000_000
        dt_utc = self._windows_epoch + timedelta(seconds=seconds_since_1601)
        return dt_utc.astimezone(self._local_tz)
    
    def _set_file_times_windows_proper(self, file_path: str, 
                                      creation_time: Optional[int] = None,
                                      modification_time: Optional[int] = None) -> bool:
        """
        Primary method: Use Windows API with proper FILETIME structures.
        
        This is the most correct way to set file times on Windows.
        
        Args:
            file_path: Path to the file or directory
            creation_time: Creation time in FILETIME format (optional)
            modification_time: Modification time in FILETIME format (optional)
            
        Returns:
            True if successful, False otherwise
        """
        handle = None
        try:
            # Determine if path is a directory
            is_directory = os.path.isdir(file_path)
            
            # Set appropriate flags
            flags = FileTimestampManager_class.FILE_ATTRIBUTE_NORMAL
            if is_directory:
                # Must use FileTimestampManager_class.FILE_FLAG_BACKUP_SEMANTICS to open directories
                flags = FileTimestampManager_class.FILE_FLAG_BACKUP_SEMANTICS
            
            # Open file/directory handle
            # Using FileTimestampManager_class.FILE_WRITE_ATTRIBUTES is more specific than GENERIC_WRITE
            handle = FileTimestampManager_class.kernel32.CreateFileW(
                file_path,
                FileTimestampManager_class.FILE_WRITE_ATTRIBUTES,  # Only need attribute write access
                FileTimestampManager_class.FILE_SHARE_READ | FileTimestampManager_class.FILE_SHARE_WRITE,  # Allow other processes to read/write
                None,  # Default security
                FileTimestampManager_class.OPEN_EXISTING,  # File must exist
                flags,
                None  # No template file
            )
            
            if handle == FileTimestampManager_class.INVALID_HANDLE_VALUE:
                error_code = FileTimestampManager_class.kernel32.GetLastError()
                log_and_flush(logging.DEBUG, f"CreateFileW failed with error code: {error_code}")
                return False
            
            # Prepare FILETIME structures
            creation_ft_ptr = None
            modification_ft_ptr = None
            
            if creation_time is not None:
                creation_ft = self._u64_to_FILETIME(creation_time)
                creation_ft_ptr = ctypes.pointer(creation_ft)
            
            if modification_time is not None:
                modification_ft = self._u64_to_FILETIME(modification_time)
                modification_ft_ptr = ctypes.pointer(modification_ft)
            
            # Set file times
            # NULL for lpLastAccessTime means don't change access time
            result = FileTimestampManager_class.kernel32.SetFileTime(
                handle,
                creation_ft_ptr,      # Creation time
                None,                 # Last access time (unchanged)
                modification_ft_ptr   # Modification time
            )
            
            if not result:
                error_code = FileTimestampManager_class.kernel32.GetLastError()
                log_and_flush(logging.DEBUG, f"SetFileTime failed with error code: {error_code}")
            
            return bool(result)
            
        except Exception as e:
            log_and_flush(logging.DEBUG, f"Exception in proper method: {e}")
            return False
        finally:
            # Always close the handle if it was opened
            if handle and handle != FileTimestampManager_class.INVALID_HANDLE_VALUE:
                FileTimestampManager_class.kernel32.CloseHandle(handle)
    
    def _set_file_times_windows_fallback(self, file_path: str, 
                                        creation_time: Optional[int] = None,
                                        modification_time: Optional[int] = None) -> bool:
        """
        Fallback method: Use Windows API with c_ulonglong (simpler but less correct).
        
        This method works on most Windows systems due to little-endian memory layout,
        but is technically not the correct way to pass FILETIME structures.
        
        Args:
            file_path: Path to the file or directory
            creation_time: Creation time in FILETIME format (optional)
            modification_time: Modification time in FILETIME format (optional)
            
        Returns:
            True if successful, False otherwise
        """
        handle = None
        try:
            # Determine if path is a directory
            is_directory = os.path.isdir(file_path)
            
            # Set appropriate flags
            flags = FileTimestampManager_class.FILE_ATTRIBUTE_NORMAL
            if is_directory:
                flags = FileTimestampManager_class.FILE_FLAG_BACKUP_SEMANTICS
            
            # Open file/directory handle (using simpler approach without type hints)
            handle = ctypes.windll.kernel32.CreateFileW(
                file_path,
                wintypes.DWORD(FileTimestampManager_class.GENERIC_WRITE),
                wintypes.DWORD(FileTimestampManager_class.FILE_SHARE_READ | FileTimestampManager_class.FILE_SHARE_WRITE),
                None,
                wintypes.DWORD(FileTimestampManager_class.OPEN_EXISTING),
                wintypes.DWORD(flags),
                None
            )
            
            if handle == -1:  # Simple comparison for FileTimestampManager_class.INVALID_HANDLE_VALUE
                return False
            
            # Prepare FILETIME as c_ulonglong (fallback method)
            creation_ft = None
            modification_ft = None
            
            if creation_time is not None:
                creation_ft = ctypes.byref(ctypes.c_ulonglong(creation_time))
            
            if modification_time is not None:
                modification_ft = ctypes.byref(ctypes.c_ulonglong(modification_time))
            
            # Set file times
            result = ctypes.windll.kernel32.SetFileTime(
                handle,
                creation_ft,
                None,
                modification_ft
            )
            
            return bool(result)
            
        except Exception as e:
            log_and_flush(logging.DEBUG, f"Exception in fallback method: {e}")
            return False
        finally:
            # Always close the handle if it was opened
            if handle and handle != -1:
                ctypes.windll.kernel32.CloseHandle(handle)
    
    def copy_timestamps(self, source_file: Union[str, Path], 
                       target_file: Union[str, Path]) -> bool:
        """
        Copy timestamps from source file to target file.
        
        This is a convenience method that combines get_file_timestamps
        and set_file_timestamps.
        
        Args:
            source_file: Source file path
            target_file: Target file path
            
        Returns:
            True if successful, False otherwise
        """
        if self._dry_run:
            log_and_flush(logging.INFO, f"[DRY RUN] Would copy timestamps from {source_file} to {target_file}")
            return True
            
        try:
            # Get timestamps from source
            creation_time, modification_time = self.get_file_timestamps(source_file)
            
            # Set timestamps on target
            success = self.set_file_timestamps(target_file, creation_time, modification_time)
            
            if success:
                log_and_flush(logging.DEBUG, f"Successfully copied timestamps from {source_file} to {target_file}")
            
            return success
            
        except Exception as e:
            log_and_flush(logging.ERROR, f"Error copying timestamps: {e}")
            return False
    
    def verify_timestamps(self, file_path: Union[str, Path], 
                         expected_creation: Optional[datetime] = None,
                         expected_modification: Optional[datetime] = None,
                         tolerance_seconds: float = 1.0) -> bool:
        """
        Verify that a file has the expected timestamps (within tolerance).
        
        Useful for testing and validation.
        
        Args:
            file_path: Path to verify
            expected_creation: Expected creation time (optional)
            expected_modification: Expected modification time (optional)
            tolerance_seconds: Acceptable difference in seconds
            
        Returns:
            True if timestamps match within tolerance, False otherwise
        """
        try:
            actual_creation, actual_modification = self.get_file_timestamps(file_path)
            
            if expected_creation is not None:
                diff = abs((actual_creation - expected_creation).total_seconds())
                if diff > tolerance_seconds:
                    log_and_flush(logging.DEBUG, f"Creation time mismatch: {diff} seconds")
                    return False
            
            if expected_modification is not None:
                diff = abs((actual_modification - expected_modification).total_seconds())
                if diff > tolerance_seconds:
                    log_and_flush(logging.DEBUG, f"Modification time mismatch: {diff} seconds")
                    return False
            
            return True
            
        except Exception as e:
            log_and_flush(logging.DEBUG, f"Error verifying timestamps: {e}")
            return False
